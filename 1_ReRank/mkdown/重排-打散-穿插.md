## 重排

排序完可以再一次重排，以达到用户体验最佳，且平台收益更好。

**Real-world-cases**: 给用户展示A、B、C就不会买任何item，而展示B、A、C就后购买A。论文给了个例子，如果把贵的商品B放前面，用户就会觉得A便宜，值得购买。

list-wise的模型给排好序的的B->A->C分别预估一个分(0.38, 0.40, 0.36)，然后按照这个分重排序，就会得到A->B->C，用户就不会购买了。

如果我们提供多个候选排列队列: A->B->C和B->A->C，然后把list-wise的分加起来，得到不同排列的分，那就会得到最优解，B->A->C。



但是一般情况下，需要重排序的item可能有上百个，上百个item做排列，再过list-wise模型预估，这是不现实的，于是论文提出了两阶段的重排序框架**PRS(Permutation Retrieve System)**，分别是**PMatch**(Permutation-Matching)阶段和**PRank**(PermutationRanking)阶段，整体架构如下图所示。

### PMatch

<img src="C:\Users\ankai2\AppData\Roaming\Typora\typora-user-images\image-20211018112255457.png" alt="image-20211018112255457" style="zoom:50%;" />



**把上百个item的排列都给list-wise模型预估排列分不现实，PMatch负责挑选出候选的排列**。通过FPSA(快速排列搜索算法，基于beam search)

首先需要离线训练模型，预估item ctr和next score，next score表示用户看完这个item后是否会往下继续浏览。

总结一下，就是先对所有待排列的item，预估出ctr和next score，然后设定输出长度n和beam search大小k，还有两个超参数rPV(累加序列中每个item曝光的概率\*每个item会带来下次曝光的概率，这个值肯定越大越好，表示能够让用户更加深度的探索)、rIPV（累加每个item曝光的概率*点击率，这个值越大，表示序列中item被点击的概率更高）。

最后选择rSum高的排列，进入下一阶段。

### PRank

<img src="C:\Users\ankai2\AppData\Roaming\Typora\typora-user-images\image-20211018113306364.png" alt="image-20211018113306364" style="zoom:60%;" />

先离线训练一个模型，该模型输入是一个长度为n的序列 (x1, x2, ..., xn)，然后输入到Bi-LSTM里，就会得到n个隐向量，每个隐向量concat用户特征和序列中每个item的原始特征，过MLP预测点击率即可：

线上服务时，通过上述模型对每个候选排列进行点击率预估，直接把队列中每个物品的预测点击率之和作为评判标准，挑选最终的排列:





## 打散

打散是在推荐、广告、搜索系统的结果基础上，提升用户视觉体验的一种处理。主要方法是对结果进行一个呈现顺序上的重排序，令相似品类的对象分散开，避免用户疲劳。

算法端传出的推荐结果，往往具有以下几个痛点：

1. 相似品类的商品易扎堆
2. 对用户的偏好捕捉太强
3. 产生的错误容易被放大

打散算法，通过呈现顺序的改变，将相似品类分开，缓冲了推荐系统和用户的交互，提升了用户体验，是算法赋能落地的最后一步。

**打散算法的定义**：输入是算法端根据用户偏好程度排列的有序列表，每个对象拥有一个或多个需要加以区分的属性，输出的要求是将相似属性分散开后的一个列表。 

**打散算法涉及的细节**：

1. 打散程度
2. 打散依据的维度
3. 打散的性能

**打散算法解决方案**O(n)、O(nlogn)：

1. 按列打散法，打散程度高，不能结合多维度，性能表现中
2. 权重分配法，打散程度中，能结合多维度，性能表现中
3. 滑动窗口法，打散程度低，不能结合多维度，性能表现高







## 推荐系统

传统角度看推荐分两阶段：召回+排序（召回强调快，排序强调准）

召回：主要根据用户部分特征，从海量的物品库中，快速召回一小部分用户潜在感兴趣的物品，然后交给排序环节。

排序：排序环节可以融入较多特征，使用复杂模型，来精准地做个性化推荐。

**细致的推荐系统分四个环节**：召回+粗排+精排+ReRanker

1. 召回：从海量的物品库中，快速召回一小部分用户潜在感兴趣的物品
2. 粗排：担心用户召回环节返回物品数量太多，导致排序环节速度跟不上，使用粗排通过少量用户和物品特征，简单模型，对召回结果进行粗略排序，进一步减少往后传送的物品数量（粗排可用可不用，跟场景有关）
3. 精排：精准的对物品进行个性化排序，可上能承受速度极限的复杂模型
4. 重排：使用各种技术及业务策略，eg：去已读、去重、打散、多样性保证、固定类型物品插入（主要是技术产品策略主导 or 为了改进用户体验的）





